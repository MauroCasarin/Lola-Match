<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lola Match-3</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Añadir un fondo degradado al cuerpo (colores más oscuros) */
        body {
            background: linear-gradient(to bottom right, #10b981, #059669); /* Degradado más oscuro */
            min-height: 100vh; /* Asegurar que el degradado cubra toda la altura de la ventana */
            display: flex; /* Usar flexbox para centrar el contenido */
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 1rem; /* Añadir algo de relleno */
            font-family: sans-serif; /* Fuente por defecto */
        }

        /* Estilos personalizados para el tablero de juego */
        #game-board {
            display: grid;
            /* Las columnas y filas de la cuadrícula se establecerán con JavaScript */
            gap: 2px; /* Pequeño espacio entre piezas */
            background-color: rgba(0, 0, 0, 0.3); /* Fondo del tablero más oscuro y semi-transparente */
            border-radius: 8px; /* Bordes redondeados para el tablero */
            padding: 5px; /* Relleno alrededor del tablero */
            margin: 20px auto; /* Centrar el tablero y añadir margen */
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4); /* Sombra más pronunciada */
            width: 100%; /* Hacer el tablero responsivo */
            max-width: 500px; /* Ancho máximo para pantallas más grandes */
            aspect-ratio: 1 / 1; /* Mantener una relación de aspecto cuadrada */
        }

        .game-piece {
            width: 100%; /* Las piezas llenan su celda de la cuadrícula */
            height: 100%;
            object-fit: contain; /* Asegurar que la imagen completa sea visible */
            cursor: pointer; /* Indicar que es clickeable */
            transition: transform 0.1s ease-in-out; /* Transición suave al pasar el ratón/clic */
            border-radius: 4px; /* Bordes redondeados para las piezas */
            /* Añadir transición para la animación de caída */
            transition: transform 0.4s ease-out, opacity 0.4s ease-out;
        }

        .game-piece:hover {
            transform: scale(1.05); /* Ligeramente más grande al pasar el ratón */
        }

        .selected {
            border: 3px solid #00f; /* Borde azul para la pieza seleccionada */
            box-sizing: border-box; /* Incluir el borde en el tamaño total del elemento */
        }

        /* CSS para la animación de cascada */
        .falling {
            transform: translateY(-100%); /* Empezar fuera de pantalla arriba */
            opacity: 0; /* Empezar invisible */
        }

        /* CSS para la animación de "explosión" al hacer match */
        .exploding {
            animation: explode 0.4s ease-out forwards; /* Aplicar la animación */
        }

        @keyframes explode {
            0% {
                transform: scale(1) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: scale(0.5) rotate(10deg); /* Reducir tamaño y rotar ligeramente */
                opacity: 0; /* Desvanecer */
            }
        }


        /* Ajustes responsivos */
        @media (max-width: 600px) {
            #game-board {
                margin: 10px auto;
            }
        }
    </style>
</head>
<body class="bg-gray-100 flex flex-col items-center justify-center min-h-screen p-4">

    <h1 class="text-4xl font-bold mb-6 text-blue-600">Lola Match-3</h1>

    <div class="w-full flex justify-center mb-4">
        <div id="score-display" class="text-2xl font-semibold text-gray-700">Puntuación: 0</div>
    </div>


    <div id="game-board" class="w-full max-w-lg">
        </div>

    <button id="restart-button" class="mt-6 px-6 py-3 bg-green-500 text-white font-bold rounded-lg shadow-lg hover:bg-green-600 transition duration-300">
        Reiniciar Juego
    </button>

    <script>
        const boardSize = 8; // Tablero de 8x8
        const pieceTypes = [
            'https://raw.githubusercontent.com/MauroCasarin/Lola-Match/refs/heads/main/im1.svg',
            'https://raw.githubusercontent.com/MauroCasarin/Lola-Match/refs/heads/main/im2.svg',
            'https://raw.githubusercontent.com/MauroCasarin/Lola-Match/refs/heads/main/im3.svg',
            'https://raw.githubusercontent.com/MauroCasarin/Lola-Match/refs/heads/main/im4.svg',
            'https://raw.githubusercontent.com/MauroCasarin/Lola-Match/refs/heads/main/im5.svg',
            'https://raw.githubusercontent.com/MauroCasarin/Lola-Match/refs/heads/main/im6.svg'
        ];

        let board = [];
        let score = 0;
        let selectedPiece = null; // Para almacenar el elemento de la pieza actualmente seleccionada
        let isSwapping = false; // Indicador para evitar múltiples intercambios a la vez

        const gameBoard = document.getElementById('game-board');
        const scoreDisplay = document.getElementById('score-display');
        const restartButton = document.getElementById('restart-button');

        // Configurar las columnas/filas de la cuadrícula según el tamaño del tablero
        gameBoard.style.gridTemplateColumns = `repeat(${boardSize}, 1fr)`;
        gameBoard.style.gridTemplateRows = `repeat(${boardSize}, 1fr)`;

        // Función para crear un elemento de pieza
        function createPiece(row, col, type) {
            const img = document.createElement('img');
            img.src = type;
            img.classList.add('game-piece');
            img.dataset.row = row;
            img.dataset.col = col;
            img.draggable = false; // Evitar el comportamiento de arrastre predeterminado del navegador
            img.addEventListener('click', handlePieceClick);
            return img;
        }

        // Función para inicializar el tablero de juego con piezas aleatorias
        function initializeBoard() {
            board = [];
            gameBoard.innerHTML = ''; // Limpiar el tablero anterior
            score = 0;
            updateScoreDisplay();
            selectedPiece = null;
            isSwapping = false;

            for (let r = 0; r < boardSize; r++) {
                board[r] = [];
                for (let c = 0; c < boardSize; c++) {
                    // Seleccionar un tipo de pieza aleatorio
                    let randomType = pieceTypes[Math.floor(Math.random() * pieceTypes.length)];

                    // Verificación simple para evitar coincidencias inmediatas al generar (se puede mejorar)
                    while ((c >= 2 && board[r][c - 1] === randomType && board[r][c - 2] === randomType) ||
                           (r >= 2 && board[r - 1][c] === randomType && board[r - 2][c] === randomType)) {
                        randomType = pieceTypes[Math.floor(Math.random() * pieceTypes.length)];
                    }

                    board[r][c] = randomType;
                    const pieceElement = createPiece(r, c, randomType);
                    gameBoard.appendChild(pieceElement);
                }
            }
            // Después de inicializar, verificar y eliminar cualquier coincidencia inicial
            setTimeout(handleMatches, 500); // Añadir un ligero retraso
        }

        // Función para actualizar la visualización de la puntuación
        function updateScoreDisplay() {
            scoreDisplay.textContent = `Puntuación: ${score}`;
        }

        // Función para manejar el clic en una pieza
        function handlePieceClick(event) {
            if (isSwapping) return; // Evitar clics durante la animación de intercambio

            const clickedPiece = event.target;

            if (!selectedPiece) {
                // Primera pieza seleccionada
                selectedPiece = clickedPiece;
                selectedPiece.classList.add('selected');
            } else if (selectedPiece === clickedPiece) {
                // Deseleccionar la misma pieza
                selectedPiece.classList.remove('selected');
                selectedPiece = null;
            } else {
                // Segunda pieza seleccionada, intentar un intercambio
                const row1 = parseInt(selectedPiece.dataset.row);
                const col1 = parseInt(selectedPiece.dataset.col);
                const row2 = parseInt(clickedPiece.dataset.row);
                const col2 = parseInt(clickedPiece.dataset.col);

                // Verificar si las piezas son adyacentes (horizontal o verticalmente)
                const isAdjacent = (Math.abs(row1 - row2) + Math.abs(col1 - col2)) === 1;

                if (isAdjacent) {
                    attemptSwap(selectedPiece, clickedPiece);
                } else {
                    // No son adyacentes, deseleccionar la primera y seleccionar la nueva
                    selectedPiece.classList.remove('selected');
                    selectedPiece = clickedPiece;
                    selectedPiece.classList.add('selected');
                }
            }
        }

        // Función para intentar un intercambio y verificar coincidencias
        async function attemptSwap(piece1, piece2) {
            isSwapping = true; // Establecer indicador de intercambio

            const row1 = parseInt(piece1.dataset.row);
            const col1 = parseInt(piece1.dataset.col);
            const row2 = parseInt(piece2.dataset.row);
            const col2 = parseInt(piece2.dataset.col);

            // Intercambiar visualmente las piezas
            swapElements(piece1, piece2);

            // Intercambiar temporalmente en el array del tablero
            [board[row1][col1], board[row2][col2]] = [board[row2][col2], board[row1][col1]];

            // Verificar coincidencias después del intercambio
            const matches = findMatches();

            if (matches.length > 0) {
                // Coincidencias encontradas, manejarlas
                await new Promise(resolve => setTimeout(resolve, 300)); // Pequeño retraso para el intercambio visual
                handleMatches();
            } else {
                // No hay coincidencias, intercambiar de vuelta
                await new Promise(resolve => setTimeout(resolve, 300)); // Pequeño retraso antes de intercambiar de vuelta
                swapElements(piece1, piece2); // Intercambiar visualmente de vuelta
                // Intercambiar de vuelta en el array del tablero
                [board[row1][col1], board[row2][col2]] = [board[row2][col2], board[row1][col1]];
            }

            // Deseleccionar piezas
            piece1.classList.remove('selected');
            piece2.classList.remove('selected');
            selectedPiece = null;
            isSwapping = false; // Restablecer indicador de intercambio
        }

        // Función para intercambiar visualmente dos elementos de pieza
        function swapElements(el1, el2) {
            const parent = el1.parentNode;
            const next1 = el1.nextSibling;
            const next2 = el2.nextSibling;

            if (next1 === el2) {
                parent.insertBefore(el2, el1);
            } else if (next2 === el1) {
                parent.insertBefore(el1, el2);
            } else {
                parent.insertBefore(el2, next1);
                parent.insertBefore(el1, next2);
            }

            // Intercambiar sus atributos de datos de fila/columna
            const row1 = el1.dataset.row;
            const col1 = el1.dataset.col;
            el1.dataset.row = el2.dataset.row;
            el1.dataset.col = el2.dataset.col;
            el2.dataset.row = row1;
            el2.dataset.col = col1;
        }

        // Función para encontrar todas las coincidencias en el tablero
        function findMatches() {
            const matches = [];
            const visited = new Set(); // Para evitar añadir la misma pieza varias veces

            // Verificar coincidencias horizontales
            for (let r = 0; r < boardSize; r++) {
                for (let c = 0; c < boardSize - 2; c++) {
                    const pieceType = board[r][c];
                    if (pieceType && board[r][c + 1] === pieceType && board[r][c + 2] === pieceType) {
                        // Se encontró una coincidencia horizontal de 3 o más
                        let matchLength = 0;
                        let currentC = c;
                        while (currentC < boardSize && board[r][currentC] === pieceType) {
                            const pieceId = `${r}-${currentC}`;
                            if (!visited.has(pieceId)) {
                                matches.push({ row: r, col: currentC });
                                visited.add(pieceId);
                            }
                            currentC++;
                            matchLength++;
                        }
                        c += matchLength - 1; // Saltar piezas ya verificadas en esta fila
                    }
                }
            }

            // Verificar coincidencias verticales
            for (let c = 0; c < boardSize; c++) {
                for (let r = 0; r < boardSize - 2; r++) {
                    const pieceType = board[r][c];
                    if (pieceType && board[r + 1][c] === pieceType && board[r + 2][c] === pieceType) {
                         // Se encontró una coincidencia vertical de 3 o más
                         let matchLength = 0;
                         let currentR = r;
                         while (currentR < boardSize && board[currentR][c] === pieceType) {
                             const pieceId = `${currentR}-${c}`;
                             if (!visited.has(pieceId)) {
                                 matches.push({ row: currentR, col: c });
                                 visited.add(pieceId);
                             }
                             currentR++;
                             matchLength++;
                         }
                         r += matchLength - 1; // Saltar piezas ya verificadas en esta columna
                    }
                }
            }

            return matches;
        }

        // Función para manejar las coincidencias encontradas (eliminar, puntuar, caer, rellenar)
        async function handleMatches() {
            let matches = findMatches();

            while (matches.length > 0) {
                // Añadir puntuación basada en el número de piezas coincidentes
                score += matches.length * 10; // 10 puntos por pieza
                updateScoreDisplay();

                // Aplicar animación de "explosión" y luego eliminar
                matches.forEach(match => {
                    const pieceElement = gameBoard.querySelector(`[data-row='${match.row}'][data-col='${match.col}']`);
                    if (pieceElement) {
                        pieceElement.classList.add('exploding'); // Añadir clase para la animación
                        // Eliminar el elemento después de que la animación termine
                        pieceElement.addEventListener('animationend', () => {
                            pieceElement.remove();
                        }, { once: true }); // Eliminar el listener después de una ejecución
                    }
                    board[match.row][match.col] = null; // Marcar como vacío en el array
                });

                // Esperar a que la animación de eliminación termine (debe coincidir con la duración de la animación CSS)
                await new Promise(resolve => setTimeout(resolve, 400)); // La animación dura 0.4s

                // Hacer caer las piezas para llenar los espacios vacíos
                dropPieces();

                // Esperar a que las piezas caigan visualmente (se puede añadir animación aquí)
                 await new Promise(resolve => setTimeout(resolve, 300)); // Ajustar retraso según sea necesario

                // Rellenar los espacios vacíos en la parte superior y animar
                await refillBoard(); // Esperar a que la animación de rellenado se complete

                // Esperar a que la animación de caída/rellenado se asiente
                await new Promise(resolve => setTimeout(resolve, 400));

                // Verificar nuevas coincidencias creadas al caer/rellenar
                matches = findMatches();
            }
        }

        // Función para hacer caer las piezas para llenar los espacios vacíos
        function dropPieces() {
            for (let c = 0; c < boardSize; c++) {
                let emptySpaces = 0;
                for (let r = boardSize - 1; r >= 0; r--) {
                    if (board[r][c] === null) {
                        emptySpaces++;
                    } else if (emptySpaces > 0) {
                        // Mover la pieza hacia abajo en el array del tablero
                        board[r + emptySpaces][c] = board[r][c];
                        board[r][c] = null;

                        // Actualizar el atributo data-row del elemento de la pieza para un posicionamiento correcto
                        const pieceElement = gameBoard.querySelector(`[data-row='${r}'][data-col='${c}']`);
                        if (pieceElement) {
                             pieceElement.dataset.row = r + emptySpaces;
                             // La función renderBoard se encargará de la actualización visual
                        }
                    }
                }
            }
             // Volver a renderizar el tablero para reflejar las nuevas posiciones de las piezas caídas
             renderBoard();
        }

        // Función para rellenar los espacios vacíos en la parte superior del tablero con animación de cascada
        async function refillBoard() {
             const newPieces = [];
             for (let r = 0; r < boardSize; r++) {
                 for (let c = 0; c < boardSize; c++) {
                     if (board[r][c] === null) {
                         // Crear un nuevo tipo de pieza aleatorio
                         const randomType = pieceTypes[Math.floor(Math.random() * pieceTypes.length)];
                         board[r][c] = randomType;
                         // Crear el nuevo elemento de pieza
                         const pieceElement = createPiece(r, c, randomType);

                         // Añadir la clase 'falling' para iniciar la animación
                         pieceElement.classList.add('falling');

                         // Establecer la posición final antes de añadir al DOM
                         pieceElement.dataset.row = r; // Establecer la fila correcta
                         pieceElement.dataset.col = c; // Establecer la columna correcta

                         // Necesario insertar la nueva pieza en la posición correcta en el DOM
                         // Encontrar la pieza que debería estar después de esta nueva pieza en el orden de la cuadrícula
                         let nextElement = null;
                         if (c < boardSize - 1) {
                             nextElement = gameBoard.querySelector(`[data-row='${r}'][data-col='${c + 1}']`);
                         } else if (r < boardSize - 1) {
                             nextElement = gameBoard.querySelector(`[data-row='${r + 1}'][data-col='${0}']`);
                         }

                         if (nextElement) {
                             gameBoard.insertBefore(pieceElement, nextElement);
                         } else {
                             gameBoard.appendChild(pieceElement);
                         }

                         newPieces.push(pieceElement);
                     }
                 }
             }

             // Activar la animación para las nuevas piezas con un efecto de cascada
             await new Promise(resolve => {
                 newPieces.forEach((piece, index) => {
                     const row = parseInt(piece.dataset.row);
                     // Calcular el retraso basado en la fila para el efecto de cascada
                     const delay = row * 50; // 50ms de retraso por fila

                     setTimeout(() => {
                         piece.classList.remove('falling'); // Eliminar la clase para activar la transición
                         piece.style.transform = 'translateY(0)'; // Mover a la posición final
                         piece.style.opacity = '1'; // Desvanecer
                         if (index === newPieces.length - 1) {
                             // Resolver la promesa después de que comience la animación de la última pieza
                             // Añadir un pequeño retraso adicional para asegurar que la animación se complete antes del siguiente paso
                             setTimeout(resolve, 400 + delay);
                         }
                     }, delay);
                 });
                 // Si no hay nuevas piezas, resolver inmediatamente
                 if (newPieces.length === 0) {
                     resolve();
                 }
             });

             // Después de la animación, volver a renderizar para asegurar el orden correcto del DOM y limpiar estilos
             renderBoard();
        }

        // Función para volver a renderizar todo el tablero basándose en el estado actual del array del tablero
        // Esta función se llama después de caídas y rellenados para asegurar que el DOM refleje el array del tablero
        function renderBoard() {
            // Almacenar los datos de la pieza seleccionada actual si la hay
            const selectedRow = selectedPiece ? parseInt(selectedPiece.dataset.row) : null;
            const selectedCol = selectedPiece ? parseInt(selectedPiece.dataset.col) : null;

            gameBoard.innerHTML = ''; // Limpiar los elementos DOM actuales
            const fragment = document.createDocumentFragment(); // Usar fragmento para rendimiento

            for (let r = 0; r < boardSize; r++) {
                for (let c = 0; c < boardSize; c++) {
                    const pieceType = board[r][c];
                    if (pieceType !== null) {
                         const pieceElement = createPiece(r, c, pieceType);
                         // Volver a aplicar la clase 'selected' si esta era la pieza seleccionada
                         if (r === selectedRow && c === selectedCol) {
                             pieceElement.classList.add('selected');
                             selectedPiece = pieceElement; // Actualizar la referencia de selectedPiece
                         }
                         fragment.appendChild(pieceElement);
                    }
                }
            }
            gameBoard.appendChild(fragment); // Añadir todas las piezas a la vez
        }


        // Listener de eventos para el botón de reiniciar
        restartButton.addEventListener('click', initializeBoard);

        // Inicializar el juego cuando la página se carga
        window.onload = initializeBoard;

    </script>
</body>
</html>
